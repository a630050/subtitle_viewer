<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>字幕神器 - 導播端</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=KaiTi&display=swap" rel="stylesheet">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft JhengHei", Roboto, sans-serif; margin: 0; display: flex; height: 100vh; background-color: #f0f2f5; overflow: hidden; }
        .main-container { display: flex; width: 100%; height: 100%; }

        /* Left Pane: Editor + Sidebar */
        .editor-pane { flex: 3; display: flex; flex-direction: column; padding: 1em; height: 100%; box-sizing: border-box; gap: 0.5em; overflow: hidden; }
        .editor-pane h3 { font-size: 1.5em; margin: 0; }
        .editor-area { display: flex; flex-direction: row; flex-grow: 1; gap: 1em; position: relative; align-items: stretch; }
        
        /* Collapsible Bookmark Sidebar */
        #bookmark-sidebar { 
            flex: 1; /* Use flex for sizing */
            min-width: 0; /* Allow shrinking */
            transition: all 0.3s ease;
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
            height: 100%; /* 確保與編輯器容器同高 */
            max-height: 100%; /* 限制最大高度 */
            position: relative; /* 為絕對定位的書籤列表提供定位基準 */
        }
        #bookmark-sidebar.collapsed { flex: 0 0 0px; min-width: 0; padding: 0; border: none; margin-left: -1em; }
        #bookmark-sidebar h3 { margin-bottom: 10px; white-space: nowrap; }
        #bookmarks-list { 
            list-style-type: none; 
            padding: 0; 
            overflow-y: scroll; 
            border-top: 1px solid #eee; 
            position: absolute;
            top: 50px; /* 標題高度 */
            left: 15px;
            right: 15px;
            bottom: 15px;
        }
        #bookmarks-list li { padding: 8px; border-bottom: 1px solid #eee; cursor: pointer; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #bookmarks-list li:hover { background-color: #f5f5f5; }
        .author-signature { 
            margin-left: 15px; 
            padding: 5px 10px; 
            font-size: 12px; 
            color: #666; 
            background-color: rgba(249, 249, 249, 0.9); 
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft JhengHei", Roboto, sans-serif;
            white-space: nowrap;
            display: flex;
            align-items: center;
        }

        /* Editor Area */
        .editor-wrapper { position: relative; flex: 3; /* Use flex for sizing */ border: 1px solid #ccc; border-radius: 4px; background-color: #fff; height: 100%; }
        #sidebar-toggle-btn { 
            position: absolute; 
            top: 50%; 
            left: -1px;
            transform: translateY(-50%); 
            width: 18px; height: 60px; background-color: #e0e0e0; color: #555;
            border: 1px solid #ccc; 
            cursor: pointer; z-index: 10;
            display: flex; align-items: center; justify-content: center; font-size: 1.2em;
            border-radius: 0 8px 8px 0; user-select: none;
        }
        #bookmark-sidebar.collapsed + .editor-wrapper #sidebar-toggle-btn { transform: translateY(-50%) scaleX(-1); }

        #line-numbers {
            position: absolute;
            left: 0;
            top: 0;
            width: 60px; /* Initial width, will be adjusted by JS */
            height: 100%;
            box-sizing: border-box;
            font-family: monospace; 
            font-size: 16px; 
            line-height: 1.6; 
            padding: 10px 0px 10px 18px; 
            background-color: #f7f7f7; 
            color: #aaa; 
            text-align: right; 
            user-select: none; 
            border-right: 1px solid #eee; 
            overflow: hidden; /* Hide all scrollbars */
            cursor: pointer; 
        }
		#line-numbers div {
			position: relative;
			padding-left: 50px;
			padding-right: 0px;
            padding-top: 0;
			transition: all 0.2s;
			box-sizing: border-box;
			width: 100%;
            height: auto;
            min-height: 25.6px;
			display: flex;
			justify-content: flex-end;
			align-items: flex-start; /* Aligns number to the top of the line block */
		}
        .bookmark-dot { position: absolute; left: 8px; top: 12.8px; transform: translateY(-50%); width: 10px; height: 10px; background-color: #3498db; border-radius: 50%; }
        
        .highlight-active {
            background-color: #ffc107 !important;
            color: #000 !important; 
            font-weight: bold; 
        }
        .highlight-blank {
            background-color: #cccccc !important;
            color: #000 !important; 
            font-weight: bold; 
        }
        
        #script-editor {
            position: absolute;
            left: 60px;
            top: 0;
            width: calc(100% - 60px);
            height: 100%;
            box-sizing: border-box;
            font-family: monospace;
            font-size: 16px; 
            line-height: 1.6; 
            border: none; 
            padding: 10px 10px 10px 5px; 
            resize: none; 
            outline: none;
            background-color: #fff;
            overflow-y: scroll;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            overflow-x: hidden;
        }

        /* Right Pane: Controls */
        .control-pane { flex: 1; border-left: 1px solid #ccc; background-color: #fff; padding: 1em; display: flex; flex-direction: column; overflow-y: auto; }
        .control-box { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin-bottom: 20px; }
        .control-box h3 { margin-top: 0; font-size: 1.1em; font-weight: bold; }
        
        #current-subtitle { aspect-ratio: 1920 / 1080; width: 100%; padding: 0; display: flex; flex-direction: column; justify-content: center; overflow: hidden; font-weight: bold; line-height: 1.4; border-radius: 3px; background-color: #000;}
        #current-subtitle span { 
            width: 100%;
            box-sizing: border-box;
            transition: opacity 0.3s ease-in-out;
        }
        #current-subtitle span.hidden {
            opacity: 0;
        }

        .config-buttons button { width: 100%; padding: 8px; font-size: 14px; cursor: pointer; }
        .file-buttons button { padding: 4px 8px; font-size: 14px; cursor: pointer; flex: 1; white-space: nowrap; }
        .file-buttons, .config-buttons { display: flex; gap: 10px; }
        .style-control { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .style-control label { flex-basis: 40%; }
        .style-control input, .style-control select { flex-basis: 55%; padding: 5px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 3px; }
        .config-buttons { margin-top: 15px; }
        
        #status { position: fixed; bottom: 10px; right: 10px; background-color: rgba(0,0,0,0.7); color: white; padding: 5px 10px; border-radius: 5px; font-size: 14px; }
        #file-input, #config-input { display: none; }
        .share-box input { width: 100%; box-sizing: border-box; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .modal-content { background-color: #fff; padding: 20px; border-radius: 5px; text-align: center; }

        #viewer-link-anchor {
            display: block;
            padding: 8px;
            background-color: #e9ecef;
            border: 1px solid #ced4da;
            border-radius: 4px;
            color: #007bff;
            text-decoration: none;
            word-break: break-all;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        #viewer-link-anchor:hover {
            background-color: #dde4ea;
            text-decoration: underline;
        }
        
        .speech-btn { background-color: #4CAF50; color: white; border: none; padding: 8px 16px; text-align: center; text-decoration: none; display: inline-block; font-size: 14px; margin: 4px 2px; cursor: pointer; border-radius: 4px; transition: background-color 0.3s; }
        .speech-btn:hover { background-color: #45a049; }
        .speech-btn.recording { background-color: #f44336; animation: pulse 1.5s infinite; }
        
        @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.7; } 100% { opacity: 1; } }
        .speech-btn.recording::after { content: " (錄音中...)"; }
        .speech-status { margin-top: 10px; padding: 8px; border-radius: 4px; font-size: 14px; text-align: center; }
        .speech-status.error { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; }
        .speech-status.success { background-color: #e8f5e9; color: #2e7d32; border: 1px solid #c8e6c9; }
        .settings-btn { background-color: #007bff; color: white; border: none; border-radius: 4px; padding: 5px 10px; font-size: 14px; cursor: pointer; transition: background-color 0.3s; }
        .settings-btn:hover { background-color: #0056b3; }
        
        #style-settings-modal .modal-content { width: 500px; max-width: 90vw; max-height: 90vh; overflow-y: auto; padding: 25px; }
        .settings-tabs { display: flex; border-bottom: 1px solid #ddd; margin-bottom: 15px; }
        .settings-tab { padding: 8px 15px; cursor: pointer; background-color: #f1f1f1; border: 1px solid #ddd; border-bottom: none; margin-right: 5px; border-radius: 5px 5px 0 0; }
        .settings-tab.active { background-color: white; border-bottom: 1px solid white; margin-bottom: -1px; font-weight: bold; }
        .settings-panel { display: none; }
        .settings-panel.active { display: block; }

        /* Night Mode Easter Egg */
        body.night-mode { background-color: #1e1e1e; color: #e0e0e0; }
        body.night-mode .editor-pane, body.night-mode .main-container { background-color: #1e1e1e; }
        body.night-mode .control-pane, body.night-mode #bookmark-sidebar, body.night-mode .editor-wrapper, body.night-mode .control-box { background-color: #252526; border-color: #3c3c3c; }
        body.night-mode #script-editor { background-color: #252526; color: #e0e0e0; }
        body.night-mode #line-numbers { background-color: #333; color: #858585; border-right-color: #3c3c3c; }
        body.night-mode .highlight-active { background-color: #007acc !important; color: #fff !important; }
        body.night-mode .highlight-blank { background-color: #555 !important; color: #fff !important; }
        body.night-mode h3, body.night-mode h4 { color: #e0e0e0; }
        body.night-mode button, body.night-mode .fab-menu-item { background-color: #3e3e42; color: #e0e0e0; border: 1px solid #555; }
        body.night-mode button:hover, body.night-mode .fab-menu-item:hover { background-color: #555; }
        body.night-mode .speech-btn { background-color: #007acc; color: white; border: none; }
        body.night-mode .speech-btn:hover { background-color: #005f9e; }
        body.night-mode .speech-btn.recording { background-color: #c72c41; }
        body.night-mode select, body.night-mode input[type=text], body.night-mode input[type=number] { background-color: #3c3c3c; color: #e0e0e0; border-color: #555; }
        body.night-mode #bookmarks-list li { border-bottom-color: #3c3c3c; }
        body.night-mode #bookmarks-list li:hover { background-color: #3e3e42; }
        body.night-mode #sidebar-toggle-btn { background-color: #3e3e42; color: #e0e0e0; border-color: #555; }
        body.night-mode .author-signature { background-color: #252526; color: #858585; border-color: #3c3c3c; cursor: pointer; }
        body.night-mode #viewer-link-anchor { background-color: #333; color: #8ab4f8; border-color: #555; }
        body.night-mode #viewer-link-anchor:hover { background-color: #444; }
        body.night-mode .settings-tab { background-color: #333; border-color: #555; }
        body.night-mode .settings-tab.active { background-color: #252526; border-bottom-color: #252526; }
        body.night-mode .modal-content { background-color: #2d2d2d; }
        body.night-mode .speech-status.error { background-color: #5c2323; color: #ffb1b1; border-color: #8c3333; }
        body.night-mode .speech-status.success { background-color: #224a22; color: #b3e6b3; border-color: #336633; }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="editor-pane">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <h3>文本編輯區</h3>
				
                <div class="file-buttons" style="display: flex; align-items: center; gap: 10px;">
					<select id="speech-lang-select" style="padding: 4px 8px; font-size: 14px; border-radius: 4px; border: 1px solid #ccc;">
						<option value="zh-TW" selected>繁體中文</option>
						<option value="en-US">English</option>
						<option value="ja-JP">日本語</option>
					</select>
					<button id="speech-toggle-btn" class="speech-btn" style="padding: 4px 12px; white-space: nowrap; margin-right: 15px;">開始語音識別</button>		
				
				
				
                    <button id="import-btn">匯入文本</button>
                    <button id="export-btn">匯出文本</button>
                    <button id="clear-btn">清除文本</button>
                    <button id="leave-room-btn">離開房間</button>

                    <div class="author-signature">程式作者：徐承佑</div>
                </div>
				
				
            </div>
			
			<div id="speech-status" class="speech-status" style="display: none; margin: 0 0 0.5em 0;"></div>
			
            <div class="editor-area">
                <div id="bookmark-sidebar" class="control-box">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="margin: 0;">書籤列表</h3>
                        <div>
                            <button id="goto-first-line-btn" style="padding: 2px 8px; font-size: 12px; cursor: pointer;">首行</button>
                            <button id="goto-last-line-btn" style="padding: 2px 8px; font-size: 12px; cursor: pointer; margin-left: 5px;">末行</button>
                        </div>
                    </div>
                    <ul id="bookmarks-list"></ul>
                </div>
                <div class="editor-wrapper">
                    <div id="sidebar-toggle-btn">&laquo;</div>
                    <div id="line-numbers"></div>
                    <div id="line-measure" style="position: absolute; top: -9999px; left: 0; visibility: hidden; white-space: pre-wrap; word-wrap: break-word;"></div>
                    <textarea id="script-editor" placeholder="在此輸入或貼上文本..." wrap="soft"></textarea>
                </div>
            </div>
        </div>
        <div class="control-pane">
            <div class="control-box">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <h3>投播效果示意</h3>
					<button id="share-btn" style="padding: 5px 10px; font-size: 14px; cursor: pointer; background-color: #17a2b8; color: white; border: none; border-radius: 4px;">分享字幕</button>
                </div>
                <div id="current-subtitle"><span>...</span></div>
            </div>

            

			
		<div class="control-box">
			<h3>排版與推播設定</h3>
			<div class="settings-tabs">
				<div class="settings-tab active" data-panel="style-panel">排版設定</div>
				<div class="settings-tab" data-panel="broadcast-panel">推播設定</div>
			</div>
			
			<div id="style-panel" class="settings-panel active" style="padding-top: 15px;">
				<div class="style-control">
					<label for="font-family-select">字體</label>
					<select id="font-family-select">
						<option value="'Microsoft JhengHei', '蘋方-繁', sans-serif" selected>微軟正黑體</option>
						<option value="'Noto Sans TC', sans-serif">思源黑體</option>
						<option value="KaiTi, '標楷體', serif">標楷體</option>
						<option value="MingLiU, '細明體', serif">細明體</option>
						<option value="Arial, sans-serif">Arial</option>
						<option value="Verdana, sans-serif">Verdana</option>
					</select>
				</div>
				<div class="style-control">
					<label for="font-size-input">字體大小 (px)</label>
					<input type="number" id="font-size-input" min="10" max="200" step="2">
				</div>
				<div class="style-control">
					<label for="fg-color-input">字體顏色</label>
					<input type="color" id="fg-color-input">
				</div>
				<div class="style-control">
					<label for="bg-color-input">背景顏色</label>
					<input type="color" id="bg-color-input">
				</div>
				<div class="style-control">
					<label for="text-align-select">左右排版</label>
					<select id="text-align-select">
						<option value="left" selected>靠左</option>
						<option value="center">置中</option>
						<option value="right">靠右</option>
					</select>
				</div>
				<div class="style-control">
					<label for="vertical-align-select">上下排版</label>
					<select id="vertical-align-select">
						<option value="top">靠上</option>
						<option value="center" selected>置中</option>
						<option value="bottom">靠下</option>
					</select>
				</div>
				<div class="style-control">
					<label for="margin-input">左右留白 (px)</label>
					<input type="number" id="margin-input" min="0" max="500" step="10" value="100">
				</div>
			</div>
			
			<div id="broadcast-panel" class="settings-panel" style="padding-top: 15px;">
				<div class="style-control">
					<label for="broadcast-mode-select">投放模式</label>
					<select id="broadcast-mode-select">
						<option value="manual" selected>人工投播</option>
						<option value="automatic">自動最新行</option>
						<option value="follow_cursor">跟隨游標</option>
					</select>
				</div>
				<div class="style-control">
					<label for="display-lines-input">顯示行數</label>
					<input type="number" id="display-lines-input" min="1" max="10" value="1">
				</div>
				<div class="style-control">
					<label for="transition-mode-select">過渡方式</label>
					<select id="transition-mode-select">
						<option value="direct" selected>直接切換</option>
						<option value="fade">淡入淡出</option>
						<option value="scroll">淡出滾動</option>
						<option value="scroll-normal">正常滾動</option>
					</select>
				</div>
			</div>
			
			<div class="config-buttons" style="margin-top: 20px;">
				<button id="save-config-btn">儲存組態</button>
				<button id="load-config-btn">載入組態</button>
			</div>
		</div>			
           

        </div>
    </div>

	<div id="share-modal" class="modal-overlay" style="display: none;">
		<div class="modal-content" style="padding: 30px; text-align: left;">
			<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
				<h4 style="margin: 0;">分享字幕給觀眾</h4>
				<button id="share-modal-close-btn" style="border: none; background: none; font-size: 24px; cursor: pointer; line-height: 1;">&times;</button>
			</div>
			<p style="margin-top: 0;">點擊下方連結在新分頁開啟，或用手機掃描 QR Code 分享。</p>
			<a href="#" id="viewer-link-anchor" target="_blank" rel="noopener noreferrer">正在產生連結...</a>
			<div id="qrcode-container" style="margin: 20px auto 0 auto; min-width: 256px; min-height: 256px; display: flex; justify-content: center; align-items: center;"></div>
		</div>
	</div>


    <div id="import-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h4>載入模式</h4>
            <p>請選擇匯入文本的方式：</p>
            <button id="import-raw-btn">原文載入</button>
            <button id="import-smart-btn">智能載入</button>
            <button id="import-cancel-btn">取消</button>
            <div style="margin-top: 15px; padding: 10px; background-color: #f8f9fa; border-radius: 4px; font-size: 14px; color: #666; text-align: left;">
                <strong>智能載入：</strong><br>
                • 自動移除空白行<br>
                • 將長句按標點符號分割（每行最多20字）<br>
                • 優先在逗號、句號、問號、驚嘆號等標點處分行<br>
                <br>
                <strong>原文載入：</strong>保持原始格式，不做任何修改
            </div>
        </div>
    </div>


    
    <div id="qrcode-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="padding: 30px;">
            <h4>觀眾端連結 QR Code</h4>
            <div id="qrcode-container" style="margin: 20px 0; min-width: 256px; min-height: 256px;"></div>
            <button id="qrcode-close-btn">關閉</button>
        </div>
    </div>

    <div id="status">正在連線...</div>
    <input type="file" id="file-input" accept=".txt">
    <input type="file" id="config-input" accept=".json">

    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
    <!-- [NEW] 引入 diff-match-patch JS 函式庫 -->
    <script src="https://cdn.jsdelivr.net/gh/google/diff-match-patch@master/javascript/diff_match_patch.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const socket = io();
            const ROOM_ID = "{{ room_id }}";

            const editor = document.getElementById('script-editor'),
                  lineNumbersDiv = document.getElementById('line-numbers'),
                  lineMeasure = document.getElementById('line-measure'),
                  statusDiv = document.getElementById('status'),
                  currentSubtitleDiv = document.getElementById('current-subtitle').querySelector('span'),
                  currentSubtitleContainer = document.getElementById('current-subtitle'),
                  bookmarksList = document.getElementById('bookmarks-list'),
                  clearBtn = document.getElementById('clear-btn'),
                  importBtn = document.getElementById('import-btn'),
                  exportBtn = document.getElementById('export-btn'),
                  fileInput = document.getElementById('file-input'),
                  fontSizeInput = document.getElementById('font-size-input'),
                  fgColorInput = document.getElementById('fg-color-input'),
                  bgColorInput = document.getElementById('bg-color-input'),
                  fontFamilySelect = document.getElementById('font-family-select'),
                  textAlignSelect = document.getElementById('text-align-select'),
                  verticalAlignSelect = document.getElementById('vertical-align-select'),
                  marginInput = document.getElementById('margin-input'),
                  saveConfigBtn = document.getElementById('save-config-btn'),
                  loadConfigBtn = document.getElementById('load-config-btn'),
                  configInput = document.getElementById('config-input'),
                  importModal = document.getElementById('import-modal'),
                  importRawBtn = document.getElementById('import-raw-btn'),
                  importSmartBtn = document.getElementById('import-smart-btn'),
                  importCancelBtn = document.getElementById('import-cancel-btn'),
                  bookmarkSidebar = document.getElementById('bookmark-sidebar'),				  
                  sidebarToggleBtn = document.getElementById('sidebar-toggle-btn'),
				  viewerLinkAnchor = document.getElementById('viewer-link-anchor'),                                    
                  qrcodeContainer = document.getElementById('qrcode-container'),
                  leaveRoomBtn = document.getElementById('leave-room-btn'),
				  shareBtn = document.getElementById('share-btn'),
				  shareModal = document.getElementById('share-modal'),
				  shareModalCloseBtn = document.getElementById('share-modal-close-btn'),				  				  
                  speechLangSelect = document.getElementById('speech-lang-select'),
                  speechToggleBtn = document.getElementById('speech-toggle-btn'),
                  speechStatus = document.getElementById('speech-status'),
                  displayLinesInput = document.getElementById('display-lines-input'),
                  transitionModeSelect = document.getElementById('transition-mode-select'),
                  broadcastModeSelect = document.getElementById('broadcast-mode-select'),
                  gotoFirstLineBtn = document.getElementById('goto-first-line-btn'),
                  gotoLastLineBtn = document.getElementById('goto-last-line-btn');

            // [NEW] diff-match-patch 相關變數
            let dmp;
            try {
                dmp = new diff_match_patch();
                console.log('diff-match-patch 載入成功');
            } catch (error) {
                console.error('diff-match-patch 載入失敗:', error);
                // 如果載入失敗，使用備用方案
                dmp = null;
            }
            let lastSentText = ''; // 用於生成 patch 的前一個文本狀態
            let patchUpdateTimeout;

            let localState = { raw_text: '', lines: [], bookmarks: {}, current_index: 0, style_settings: {}, push_settings: {} };
            let editorUpdateTimeout;
            let collaborationUpdateTimeout;
            let cursorSyncTimeout;
            let importedFileContent = '';
            let heartbeatInterval;
            let lastPongTime = Date.now();
            let isBlanked = false;
            let recognition = null;
            let isRecording = false;
            let finalTranscript = '';
            let interimTranscript = '';
            let punctuationMarks = /[,.;:!?\uff0c\u3002\u3001?!;:]/;
            let sentenceEndings = /[.!?\uff01\uff1f\u3002]/;
            let lastSpeechTime = 0;
            let silenceTimer = null;
            let pendingText = '';
            let interimUpdateDelay = 100;
            let interimPushDelay = 200;
            let finalUpdateDelay = 300;
            let finalPushDelay = 100;
            let editorUpdateDebounce = 1000;
            let microPauseThreshold = 200;
            let shortPauseThreshold = 400;
            let mediumPauseThreshold = 1200;
            let longPauseThreshold = 2500;
            let silenceCheckInterval = 150;
            let editorUpdateTimer = null;
            let pushUpdateTimer = null;
            let currentInterimText = '';
            let commaCount = 0;
            let maxLineLength = 30;
            let updateTimeout = null;
            let resizeTimeout = null;

            class LineHeightCalculator {
                constructor(editor, measureDiv) {
                    this.editor = editor;
                    this.measureDiv = measureDiv;
                    this.baseLineHeight = 0;
                    this.setupMeasureDiv();
                }
                
                setupMeasureDiv() {
                    const editorStyles = window.getComputedStyle(this.editor);
                    this.measureDiv.style.font = editorStyles.font;
                    this.measureDiv.style.lineHeight = editorStyles.lineHeight;
                    this.measureDiv.style.padding = `0 ${editorStyles.paddingRight} 0 ${editorStyles.paddingLeft}`;
                    this.measureDiv.style.width = this.editor.clientWidth + 'px';
                    this.measureDiv.style.letterSpacing = editorStyles.letterSpacing;
                    this.measureDiv.style.wordSpacing = editorStyles.wordSpacing;
                    this.measureDiv.style.boxSizing = editorStyles.boxSizing;
                    this.baseLineHeight = parseFloat(editorStyles.lineHeight) || 1;
                }
                
                measureLines(lines) {
                    const lineMetrics = [];
                    for (const line of lines) {
                        this.measureDiv.textContent = line || ' ';
                        const visualHeight = this.measureDiv.offsetHeight;
                        const visualLines = this.baseLineHeight > 0 ? Math.max(1, Math.round(visualHeight / this.baseLineHeight)) : 1;
                        lineMetrics.push({
                            height: visualHeight,
                            lines: visualLines
                        });
                    }
                    return lineMetrics;
                }
            }

            socket.on('connect', () => { 
                statusDiv.textContent = '已連線 ✅'; 
                socket.emit('join', { room: ROOM_ID }); 
                startHeartbeat();
            });
            socket.on('disconnect', () => { 
                statusDiv.textContent = '連線中斷 ❌'; 
                stopHeartbeat();
            });
            socket.on('state_update', (newState) => { 
                const oldIndex = localState.current_index;
                const oldDisplayLines = localState.push_settings?.display_lines;
                const oldRawText = localState.raw_text;
                
                localState = newState;
                
                // [MODIFIED] 初始化或重置用於 patch 的文本
                lastSentText = newState.raw_text;

                updateUI(oldIndex !== newState.current_index || oldDisplayLines !== newState.push_settings?.display_lines);
                if (editor.value !== oldRawText) {
                    scheduleLineNumberUpdate();
                }
            });
            socket.on('pong', (data) => { 
                lastPongTime = Date.now();
                const latency = lastPongTime - data.timestamp;
                statusDiv.textContent = `已連線 ✅ (${latency}ms)`;
            });

            // [NEW] 監聽來自伺服器的文本補丁
            socket.on('script_patched', (data) => {
                if (!dmp) {
                    console.error('diff-match-patch 未載入，無法處理補丁');
                    // 請求完整狀態同步
                    socket.emit('join', { room: ROOM_ID });
                    return;
                }

                const patch_text = data.patch;
                const oldText = editor.value;
                const oldCursorPos = editor.selectionStart;

                try {
                    // 應用補丁
                    const patches = dmp.patch_fromText(patch_text);
                    const [newText, results] = dmp.patch_apply(patches, oldText);

                    if (results.some(res => !res)) {
                        // 如果補丁應用失敗，向伺服器請求完整狀態以強制同步
                        console.error("本地補丁應用失敗，請求完整狀態。");
                        socket.emit('join', { room: ROOM_ID }); // 重新加入以獲取最新狀態
                        return;
                    }

                    // 更新文本
                    editor.value = newText;
                    lastSentText = newText; // 同步本地的 patch 基準文本

                    // 智能計算並恢復游標位置
                    const diffs = dmp.diff_main(oldText, newText);
                    const newCursorPos = dmp.diff_xIndex(diffs, oldCursorPos);
                    editor.selectionStart = editor.selectionEnd = newCursorPos;
                    
                    // 手動觸發UI更新
                    scheduleLineNumberUpdate();
                    autoFollowCurrentLine(); // 如果需要，更新高亮行
                } catch (error) {
                    console.error('處理補丁時發生錯誤:', error);
                    // 發生錯誤時請求完整狀態同步
                    socket.emit('join', { room: ROOM_ID });
                }
            });

            socket.on('cursor_update', (data) => {
                const broadcastMode = localState.push_settings?.broadcast_mode || 'manual';
                if (broadcastMode === 'follow_cursor' && data.cursor_pos !== undefined) {
                    if (editor.selectionStart !== data.cursor_pos || editor.selectionEnd !== data.cursor_pos) {
                        try {
                            const currentScrollTop = editor.scrollTop;
                            editor.selectionStart = editor.selectionEnd = data.cursor_pos;
                            editor.scrollTop = currentScrollTop;
                        } catch(e) { console.error("Failed to sync cursor position:", e); }
                    }
                }
            });


            const settingsTabs = document.querySelectorAll('.settings-tab');
            

            
            settingsTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    settingsTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    document.querySelectorAll('.settings-panel').forEach(panel => panel.classList.remove('active'));
                    const panelId = tab.getAttribute('data-panel');
                    document.getElementById(panelId).classList.add('active');
                });
            });
            
            // [MODIFIED] 移除或註解掉舊的 editor_update 監聽器，因為 patch 機制已取代它
            /*
            socket.on('editor_update', (data) => {
                // ... 這個區塊的邏輯現在由 'script_patched' 處理
            });
            */

            function startHeartbeat() {
                stopHeartbeat();
                heartbeatInterval = setInterval(() => {
                    const now = Date.now();
                    socket.emit('ping', { room: ROOM_ID, timestamp: now });
                    if (now - lastPongTime > 10000) {
                        statusDiv.textContent = '連線異常 ⚠️';
                    }
                }, 60000);
            }

            function stopHeartbeat() {
                if (heartbeatInterval) {
                    clearInterval(heartbeatInterval);
                    heartbeatInterval = null;
                }
            }

            function getPushOptions() {
                return {
                    display_lines: parseInt(displayLinesInput.value) || 1,
                    transition_mode: transitionModeSelect.value
                };
            }

            function compensateForScrollbars() {
                requestAnimationFrame(() => {
                    const originalPaddingRight = '5px';
                    const originalPaddingBottom = '10px';
                    lineNumbersDiv.style.paddingRight = originalPaddingRight;
                    lineNumbersDiv.style.paddingBottom = originalPaddingBottom;
                    const scrollbarWidth = editor.offsetWidth - editor.clientWidth;
                    const scrollbarHeight = editor.offsetHeight - editor.clientHeight;
                    if (scrollbarWidth > 1) {
                        lineNumbersDiv.style.paddingRight = `${parseInt(originalPaddingRight) + scrollbarWidth}px`;
                    }
                    if (scrollbarHeight > 1) {
                        lineNumbersDiv.style.paddingBottom = `${parseInt(originalPaddingBottom) + scrollbarHeight}px`;
                    }
                });
            }

            function updateUI(indexChanged = false) {
                if (document.activeElement !== editor && editor.value !== localState.raw_text) {
                    const cursorPos = editor.selectionStart;
                    editor.value = localState.raw_text;
                    try { editor.selectionStart = editor.selectionEnd = cursorPos; } catch (e) {}
                }
                
                const pushSettings = localState.push_settings || { display_lines: 1, transition_mode: 'fade' };
                const displayLines = pushSettings.display_lines || 1;
                const transitionMode = pushSettings.transition_mode || 'fade';
                const isScroll = transitionMode === 'scroll' || transitionMode === 'scroll-normal';

                let newHtmlContent;

                if (isBlanked) {
                    newHtmlContent = '';
                } else if (isScroll) {
                    const PREVIEW_CONTEXT_LINES = 4;
                    const currentIndex = localState.current_index;
                    const activeStartIndex = Math.max(0, currentIndex - (displayLines - 1));
                    const previewStartIndex = Math.max(0, activeStartIndex - PREVIEW_CONTEXT_LINES);

                    const linesForPreview = [];
					for (let i = previewStartIndex; i <= currentIndex; i++) {
						if (i < 0 || i >= localState.lines.length) continue;

						const line = localState.lines[i];
						
						// ★ 核心修改：先處理好內容
						const cleanedLine = cleanLineForDisplay(line);
						
						// ★ 如果處理後的內容是空的，就給它一個不斷行的空格
						const content = cleanedLine || '&nbsp;';
						
						let lineHtml;

						if (i >= activeStartIndex) {
							// This is an active line
							lineHtml = `<span style="opacity: 1; display: block;">${content}</span>`;
						} else {
							// This is a previous, context line
							const opacity = (transitionMode === 'scroll') ? '0.4' : '1'; // Fade for 'scroll' mode
							lineHtml = `<span style="opacity: ${opacity}; display: block;">${content}</span>`;
						}
						linesForPreview.push(lineHtml);
					}
					
					
                    newHtmlContent = linesForPreview.join('');
                } else {
                    const startIndex = Math.max(0, localState.current_index - (displayLines - 1));
                    const linesToShow = localState.lines.slice(startIndex, localState.current_index + 1);
                    newHtmlContent = linesToShow.map(line => cleanLineForDisplay(line)).join('<br>');
                }

                if (currentSubtitleDiv.innerHTML !== newHtmlContent) {
                    if (transitionMode === 'fade' && !isScroll) {
                        currentSubtitleDiv.classList.add('hidden');
                        setTimeout(() => {
                            currentSubtitleDiv.innerHTML = newHtmlContent;
                            currentSubtitleDiv.classList.remove('hidden');
                        }, 150);
                    } else {
                        currentSubtitleDiv.innerHTML = newHtmlContent;
                    }
                }

                updateBookmarksList();
                scheduleLineNumberUpdate();
                updateStyles();

                if (document.activeElement !== broadcastModeSelect) {
                    broadcastModeSelect.value = pushSettings.broadcast_mode || 'manual';
                }
                if (document.activeElement !== displayLinesInput) {
                    displayLinesInput.value = pushSettings.display_lines;
                }
                if (document.activeElement !== transitionModeSelect) {
                    transitionModeSelect.value = pushSettings.transition_mode;
                }

                if (indexChanged) adjustScroll();
                
                // [NEW] 更新觀眾端連結
                if (localState.viewer_id) {
                    const viewerUrl = `${window.location.origin}/viewer/${localState.viewer_id}`;
                    viewerLinkAnchor.href = viewerUrl;
                    viewerLinkAnchor.textContent = viewerUrl;
                }
            }

            function updateStyles() {
                const styles = localState.style_settings || {};
                const REFERENCE_WIDTH = 1920;

                const bgColor = styles.bg_color || '#000000';
                const fgColor = styles.fg_color || '#FFFF00';
                const fontFamily = styles.font_family || "'Microsoft JhengHei', '蘋方-繁', sans-serif";
                const textAlign = styles.text_align || 'left';
                const verticalAlign = styles.vertical_align || 'center';
                const userMargin = styles.margin !== undefined ? styles.margin : 30;
                const userFontSize = styles.font_size !== undefined ? styles.font_size : 100;

                currentSubtitleContainer.style.backgroundColor = bgColor;
                currentSubtitleContainer.style.color = fgColor;
                currentSubtitleContainer.style.fontFamily = fontFamily;
                currentSubtitleContainer.style.textAlign = textAlign;
                currentSubtitleContainer.style.boxSizing = 'border-box';

                if (verticalAlign === 'top') {
                    currentSubtitleContainer.style.justifyContent = 'flex-start';
                } else if (verticalAlign === 'bottom') {
                    currentSubtitleContainer.style.justifyContent = 'flex-end';
                } else {
                    currentSubtitleContainer.style.justifyContent = 'center';
                }

                const previewWidth = currentSubtitleContainer.clientWidth;
                if (previewWidth > 0) {
                    const actualMargin = (userMargin / REFERENCE_WIDTH) * previewWidth;
                    const textAreaWidth = previewWidth - (actualMargin * 2);
                    const referenceTextAreaWidth = REFERENCE_WIDTH - (userMargin * 2);
                    const actualFontSize = (userFontSize / referenceTextAreaWidth) * textAreaWidth;

                    currentSubtitleContainer.style.paddingLeft = `${actualMargin}px`;
                    currentSubtitleContainer.style.paddingRight = `${actualMargin}px`;
                    currentSubtitleContainer.style.fontSize = `${actualFontSize}px`;
                }

                if (document.activeElement !== fontSizeInput) fontSizeInput.value = userFontSize;
                if (document.activeElement !== fgColorInput) fgColorInput.value = fgColor;
                if (document.activeElement !== bgColorInput) bgColorInput.value = bgColor;
                if (document.activeElement !== fontFamilySelect) fontFamilySelect.value = fontFamily;
                if (document.activeElement !== textAlignSelect) textAlignSelect.value = textAlign;
                if (document.activeElement !== verticalAlignSelect) verticalAlignSelect.value = styles.vertical_align || 'center';
                if (document.activeElement !== marginInput) marginInput.value = userMargin;
                
                compensateForScrollbars();
            }

            function updateBookmarksList() {
                bookmarksList.innerHTML = '';
                for (const index in localState.bookmarks) {
                    const li = document.createElement('li');
                    const bookmarkText = localState.bookmarks[index];
                    li.textContent = `${parseInt(index) + 1}: ${bookmarkText}`;
                    li.title = bookmarkText;
                    li.dataset.index = index;
                    li.addEventListener('click', () => {
                        isBlanked = false; 
                        socket.emit('update_index', { room: ROOM_ID, index: parseInt(index), ...getPushOptions() });
                    });
                    bookmarksList.appendChild(li);
                }
            }

            function scheduleLineNumberUpdate() {
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(updateLineNumbers, 150);
            }

            function updateLineNumbers() {
                const lines = editor.value.split('\n');
                const lineCount = lines.length;
                const digits = String(lineCount).length;
                const newWidth = 50 + (digits * 8) + 5;

                if (parseInt(lineNumbersDiv.style.width) !== newWidth) {
                    lineNumbersDiv.style.width = `${newWidth}px`;
                    const newLeft = `${newWidth}px`;
                    const newEditorWidth = `calc(100% - ${newWidth}px)`;
                    editor.style.left = newLeft;
                    editor.style.width = newEditorWidth;
                }

                const calculator = new LineHeightCalculator(editor, lineMeasure);
                const lineMetrics = calculator.measureLines(lines);

				// === ★ 修改：修正誤差校準機制 ===
				let correctionFactor = 1.0; // 預設校準因子為 1 (即不校準)

				// 只有當文本行數大於 30 行時，才啟用誤差校準機制
				// 這樣可以避免在文本少時，scrollHeight 回傳錯誤值導致的佈局問題
				if (lines.length > 25) {
					const totalMeasuredHeight = lineMetrics.reduce((sum, m) => sum + m.height, 0);
					
					const editorStyles = window.getComputedStyle(editor);
					const editorPaddingTop = parseFloat(editorStyles.paddingTop) || 0;
					const editorPaddingBottom = parseFloat(editorStyles.paddingBottom) || 0;
					const trueContentHeight = editor.scrollHeight - editorPaddingTop - editorPaddingBottom;

					// 再次檢查，確保計算出的總高度與真實內容高度相近，避免極端情況
					if (totalMeasuredHeight > 0 && trueContentHeight > 0 && Math.abs(trueContentHeight - totalMeasuredHeight) < editor.clientHeight) {
						correctionFactor = trueContentHeight / totalMeasuredHeight;
					}
				}

                const displayLines = localState.push_settings?.display_lines || 1;
                const startIndex = Math.max(0, localState.current_index - (displayLines - 1));
                const endIndex = localState.current_index;

                lineNumbersDiv.innerHTML = '';
                
                lines.forEach((line, logicalIndex) => {
                    const metrics = lineMetrics[logicalIndex];
                    const isHighlighted = logicalIndex >= startIndex && logicalIndex <= endIndex;
                    
                    const lineContainer = document.createElement('div');
                    // [OPTIMIZATION] Apply the correction factor to each line's height
                    const correctedHeight = metrics.height * correctionFactor;
                    lineContainer.style.height = correctedHeight + 'px';
                    
                    const numberSpan = document.createElement('span');
                    numberSpan.textContent = logicalIndex + 1;
                    // Add some top padding to the number itself to better align with the text's first line.
                    numberSpan.style.paddingTop = '0px'; 
                    lineContainer.appendChild(numberSpan);

                    if (isHighlighted) {
                        const highlightClass = isBlanked ? 'highlight-blank' : 'highlight-active';
                        lineContainer.classList.add(highlightClass);
                    }
                    
                    if (localState.bookmarks[logicalIndex] !== undefined) {
                        const dot = document.createElement('span');
                        dot.className = 'bookmark-dot';
                        lineContainer.appendChild(dot);
                    }
                    
                    lineContainer.addEventListener('click', () => {
                        isBlanked = false; 
                        socket.emit('update_index', { room: ROOM_ID, index: logicalIndex, ...getPushOptions() });
                    });
                    lineContainer.addEventListener('dblclick', () => {
                        toggleBookmark(logicalIndex);
                    });

                    lineNumbersDiv.appendChild(lineContainer);
                });
                
                lineNumbersDiv.scrollTop = editor.scrollTop;
                compensateForScrollbars();
            }

            sidebarToggleBtn.addEventListener('click', () => {
                bookmarkSidebar.classList.toggle('collapsed');
                setTimeout(scheduleLineNumberUpdate, 300);
            });

            function toggleBookmark(index) {
                const lines = editor.value.split('\n');
                if (index >= lines.length) return;
                const line = lines[index];
                if (line.trim().startsWith('§')) {
                    lines[index] = line.replace(/^§\s*/, '');
                } else {
                    lines[index] = '§ ' + line;
                }
                const newText = lines.join('\n');
                editor.value = newText;
                scheduleLineNumberUpdate();
                socket.emit('update_script', { room: ROOM_ID, raw_text: newText });
            }

			function adjustScroll() {
                try {
                    const calculator = new LineHeightCalculator(editor, lineMeasure);
                    const lines = editor.value.split('\n');
                    
                    if (lines.length === 0 || localState.current_index >= lines.length) {
                        return;
                    }

                    const lineMetrics = calculator.measureLines(lines);
                    
                    let targetY = 0;
                    for (let i = 0; i < localState.current_index; i++) {
                        targetY += lineMetrics[i].height;
                    }
                    
                    const editorHeight = editor.clientHeight;
                    const currentLineHeight = lineMetrics[localState.current_index].height;
                    const comfortZonePx = 3 * calculator.baseLineHeight; // 上下各保留約 3 行的像素高度
                    
                    const comfortTopBoundary = editor.scrollTop + comfortZonePx;
                    const comfortBottomBoundary = editor.scrollTop + editorHeight - comfortZonePx - currentLineHeight;
                    
                    // 只有當前行超出上下舒適區時，才觸發滾動
                    if (targetY < comfortTopBoundary || targetY > comfortBottomBoundary) {
                        
                        let targetScrollTop;

                        // ★ 核心修改：判斷滾動方向
                        if (targetY > comfortBottomBoundary) {
                            // 情況 1：當前行在下方，需要向上滾動
                            // 目標：讓當前行位於底部舒適區的頂部
                            targetScrollTop = targetY - editorHeight + comfortZonePx + currentLineHeight;
                        } else {
                            // 情況 2：當前行在上方，需要向下滾動
                            // 目標：讓當前行位於頂部舒適區的底部
                            targetScrollTop = targetY - comfortZonePx;
                        }

                        // 計算最大允許的滾動位置
                        const maxScrollTop = editor.scrollHeight - editor.clientHeight;

                        // 將計算出的滾動位置限制在 [0, maxScrollTop] 的有效範圍內
                        const finalScrollTop = Math.max(0, Math.min(targetScrollTop, maxScrollTop));
                        
                        editor.scrollTop = finalScrollTop;
                    }
                } catch (e) {
                    console.error("Error adjusting scroll:", e);
                }
            }

            function showImportModal(content) {
                importedFileContent = content;
                importModal.style.display = 'flex';
            }

            function smartLoad(text) {
                const lines = text.split('\n');
                const newLines = [];
                const MAX_LEN = 20;
                const punctuation = /([,\.\uff0c\u3002\u3001?!;:\s])/; 
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (trimmedLine === '') continue;
                    let currentLine = trimmedLine;
                    while (currentLine.length > MAX_LEN) {
                        let splitPos = -1;
                        for (let i = MAX_LEN; i >= 0; i--) {
                            if (i < currentLine.length && punctuation.test(currentLine[i])) {
                                splitPos = i;
                                break;
                            }
                        }
                        if (splitPos !== -1) {
                            newLines.push(currentLine.substring(0, splitPos + 1).trim());
                            currentLine = currentLine.substring(splitPos + 1).trim();
                        } else {
                            newLines.push(currentLine.substring(0, MAX_LEN));
                            currentLine = currentLine.substring(MAX_LEN).trim();
                        }
                    }
                    if (currentLine.length > 0) newLines.push(currentLine);
                }
                return newLines.join('\n');
            }

            clearBtn.addEventListener('click', () => {
                if (window.confirm('您確定要清空所有文本嗎？此操作無法復原。')) {
                    editor.value = '';
                    socket.emit('update_script', { room: ROOM_ID, raw_text: '' });
                }
            });

            importBtn.addEventListener('click', () => { fileInput.click(); });
            fileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => { showImportModal(e.target.result); };
                reader.readAsText(file, 'UTF-8');
                event.target.value = '';
            });

            exportBtn.addEventListener('click', () => {
                const textToSave = editor.value;
                const blob = new Blob([textToSave], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'text.txt';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            });

            importRawBtn.addEventListener('click', () => {
                editor.value = importedFileContent;
                socket.emit('update_script', { room: ROOM_ID, raw_text: editor.value });
                importModal.style.display = 'none';
            });

            importSmartBtn.addEventListener('click', () => {
                const processedText = smartLoad(importedFileContent);
                editor.value = processedText;
                socket.emit('update_script', { room: ROOM_ID, raw_text: editor.value });
                importModal.style.display = 'none';
            });

            importCancelBtn.addEventListener('click', () => { 
                importModal.style.display = 'none';
            });

            saveConfigBtn.addEventListener('click', () => {
                const config = localState.style_settings;
                const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = 'teleprompter-style.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(a.href);
            });

            loadConfigBtn.addEventListener('click', () => { configInput.click(); });

            configInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const newStyles = JSON.parse(e.target.result);
                        if (newStyles.font_size && newStyles.fg_color && newStyles.bg_color) {
                            socket.emit('update_styles', { room: ROOM_ID, styles: newStyles });
                        } else { alert('無效的組態檔案格式。'); }
                    } catch (err) { alert('讀取檔案失敗，請確認是否為正確的 JSON 檔案。'); console.error(err); }
                };
                reader.readAsText(file);
                event.target.value = '';
            });

            function handleStyleChange() {
                const newStyles = { 
                    font_size: parseInt(fontSizeInput.value),
                    fg_color: fgColorInput.value, 
                    bg_color: bgColorInput.value,
                    font_family: fontFamilySelect.value,
                    text_align: textAlignSelect.value,
                    vertical_align: verticalAlignSelect.value,
                    margin: parseInt(marginInput.value) || 15
                };
                socket.emit('update_styles', { room: ROOM_ID, styles: newStyles });
                Object.assign(localState.style_settings, newStyles);
                updateUI();
                
                // [NEW] 樣式變更後立即推播當前內容到觀眾端
                if (!isBlanked) {
                    const displayLines = localState.push_settings?.display_lines || 1;
                    const startIndex = Math.max(0, localState.current_index - (displayLines - 1));
                    const linesToShow = localState.lines.slice(startIndex, localState.current_index + 1);
                    const content = linesToShow.map(line => cleanLineForDisplay(line)).join('\n');
                    socket.emit('send_content', { room: ROOM_ID, text: content });
                }
            }
            [fontSizeInput, fgColorInput, bgColorInput, marginInput].forEach(el => el.addEventListener('input', handleStyleChange));
            [fontFamilySelect, textAlignSelect, verticalAlignSelect].forEach(el => el.addEventListener('change', handleStyleChange));


            function handlePushSettingsChange() {
                const settings = {
                    display_lines: parseInt(displayLinesInput.value) || 1,
                    transition_mode: transitionModeSelect.value,
                    broadcast_mode: broadcastModeSelect.value
                };
                socket.emit('update_push_settings', { room: ROOM_ID, settings: settings });
            }
            displayLinesInput.addEventListener('input', handlePushSettingsChange);
            transitionModeSelect.addEventListener('change', handlePushSettingsChange);
            broadcastModeSelect.addEventListener('change', handlePushSettingsChange);

            function broadcastEditorChanges() {
                socket.emit('editor_change', {
                    room: ROOM_ID,
                    raw_text: editor.value,
                    cursor_pos: editor.selectionStart
                });
                autoFollowCurrentLine();
            }

            function scheduleCollaborationUpdate() {
                clearTimeout(collaborationUpdateTimeout);
                collaborationUpdateTimeout = setTimeout(broadcastEditorChanges, 250);
            }

            // [MODIFIED] 替換原有的 'input' 事件監聽器
            editor.addEventListener('input', () => {
                clearTimeout(patchUpdateTimeout);
                patchUpdateTimeout = setTimeout(() => {
                    const currentText = editor.value;
                    // 僅在文本有變化時才生成和發送補丁
                    if (currentText !== lastSentText) {
                        if (dmp) {
                            // 使用 diff-patch 機制
                            const patch_text = dmp.patch_toText(dmp.patch_make(lastSentText, currentText));
                            
                            if (patch_text) {
                                socket.emit('patch_script', {
                                    room: ROOM_ID,
                                    patch: patch_text
                                });
                            }
                        } else {
                            // 備用方案：使用原始的完整文本更新
                            socket.emit('update_script', { 
                                room: ROOM_ID, 
                                raw_text: currentText 
                            });
                        }
                        
                        lastSentText = currentText; // 更新基準文本
                    }
                }, 200); // 200毫秒的延遲，避免過於頻繁發送

                // 本地UI仍然需要即時更新
                scheduleLineNumberUpdate();
                autoFollowCurrentLine();
            });

            editor.addEventListener('scroll', () => { lineNumbersDiv.scrollTop = editor.scrollTop; });

            const pushCurrentLine = () => {
                isBlanked = false; 
                const textUpToCursor = editor.value.substring(0, editor.selectionStart);
                const lineNumber = textUpToCursor.split('\n').length - 1;
                if (lineNumber !== localState.current_index || isBlanked) {
                    socket.emit('update_index', { room: ROOM_ID, index: lineNumber, ...getPushOptions() });
                }
            };

            function focusEditorAtCurrentLine() {
                editor.focus();
                const lines = editor.value.split('\n');
                let cursorPos = 0;
                for (let i = 0; i < localState.current_index; i++) {
                    cursorPos += (lines[i] || '').length + 1;
                }
                cursorPos += (lines[localState.current_index] || '').length;
                editor.selectionStart = editor.selectionEnd = cursorPos;
            }

            editor.addEventListener('contextmenu', (e) => { 
                e.preventDefault(); 
                pushCurrentLine(); 
            });

            editor.addEventListener('keydown', (e) => {
                if (e.key === 'Insert') {
                    e.preventDefault();
                    pushCurrentLine();
                }
                if (e.key === 'Escape') {
                    e.preventDefault();
                    editor.blur();
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && (e.key === '=' || e.key === '+' || e.key === '-')) {
                    e.preventDefault();
                    const currentStyles = { ...localState.style_settings };
                    let currentSize = parseInt(currentStyles.font_size);
                    const step = 2;
                    if (e.key === '=' || e.key === '+') currentSize += step;
                    else currentSize -= step;
                    currentStyles.font_size = Math.max(10, Math.min(200, currentSize));
                    socket.emit('update_styles', { room: ROOM_ID, styles: currentStyles });
                }

                if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') return;

                if (e.code === 'Space' && !e.repeat) {
                    e.preventDefault();
                    isBlanked = !isBlanked;
                    
                    if (isBlanked) {
                        socket.emit('send_content', { room: ROOM_ID, text: '' });
                    } else {
                        const displayLines = localState.push_settings?.display_lines || 1;
                        const startIndex = Math.max(0, localState.current_index - (displayLines - 1));
                        const linesToShow = localState.lines.slice(startIndex, localState.current_index + 1);
                        const content = linesToShow.map(line => cleanLineForDisplay(line)).join('\n');
                        socket.emit('send_content', { room: ROOM_ID, text: content });
                    }
                    updateUI();
                    return; 
                }

                if (e.key === 'Enter' || e.key === 'ArrowRight') {
                    e.preventDefault();
                    focusEditorAtCurrentLine();
                }

                if (['PageDown', 'ArrowDown', 'PageUp', 'ArrowUp'].includes(e.key)) {
                    e.preventDefault();
                    isBlanked = false; 
                    let newIndex = localState.current_index;
                    if (e.key === 'PageDown' || e.key === 'ArrowDown') {
                        newIndex = Math.min((localState.lines.length || 1) - 1, localState.current_index + 1);
                    } else {
                        newIndex = Math.max(0, localState.current_index - 1);
                    }
                    if (newIndex !== localState.current_index) {
                        socket.emit('update_index', { room: ROOM_ID, index: newIndex, ...getPushOptions() });
                    }
                }
            });

            document.addEventListener('contextmenu', (e) => {
                if (e.target.closest('button, a, select, input, textarea, #line-numbers, #bookmarks-list')) { return; }
                e.preventDefault();
                pushCurrentLine();
            });

            document.addEventListener('click', (e) => {
                if (e.target.closest('button, a, select, input, textarea, #line-numbers, #bookmarks-list')) {
                    return;
                }
                focusEditorAtCurrentLine();
            });

            function cleanLineForDisplay(line) { return line.replace(/^§\s*/, '').replace(/^#\s*/, ''); }

            new ResizeObserver(updateStyles).observe(currentSubtitleContainer);
            
            const editorResizeObserver = new ResizeObserver(() => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    scheduleLineNumberUpdate();
                }, 50);
            });
            editorResizeObserver.observe(editor);


            leaveRoomBtn.addEventListener('click', () => {
                if (window.confirm("您確定要離開這個房間的導播頁面嗎？\n\n（這將會中斷與伺服器的連線，並顯示一個結束畫面。）")) {
                    if (socket && socket.connected) socket.disconnect();
                    document.documentElement.innerHTML = `
                        <head>
                            <meta charset="UTF-8"><title>已離開</title>
                            <style>
                                body { background-color: #2c3e50; color: #ecf0f1; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0; font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, sans-serif; }
                                h1 { font-size: 4rem; font-weight: 300; border: 2px solid #ecf0f1; padding: 20px 40px; border-radius: 10px; }
                            </style>
                        </head>
                        <body><h1>Goodbye</h1></body>
                    `;
                }
            });
			
        // [新增] 控制分享 Modal 的事件
        shareBtn.addEventListener('click', () => {
            const url = viewerLinkAnchor.href;
            if (!url || url.includes('#') || url.includes('...')) {
                alert('連結尚未產生，請稍候...');
                return;
            }
            
            qrcodeContainer.innerHTML = ''; // 清空舊的 QR Code
            try {
                const qr = qrcode(0, 'L');
                qr.addData(url);
                qr.make();
                const dataUrl = qr.createDataURL(6, 10);
                const imgElement = document.createElement('img');
                imgElement.src = dataUrl;
                imgElement.alt = 'Viewer Link QR Code';
                imgElement.style.width = '256px';
                imgElement.style.height = '256px';
                qrcodeContainer.appendChild(imgElement);
                shareModal.style.display = 'flex'; // 顯示 Modal
            } catch (e) {
                console.error('QR Code generation failed:', e);
                alert('產生 QR Code 失敗！');
            }
        });

        // 關閉按鈕
        shareModalCloseBtn.addEventListener('click', () => {
            shareModal.style.display = 'none';
        });

        // 點擊 Modal 外部區域關閉
        shareModal.addEventListener('click', (e) => {
            if (e.target === shareModal) {
                shareModal.style.display = 'none';
            }
        });			

            gotoFirstLineBtn.addEventListener('click', () => {
                isBlanked = false;
                socket.emit('update_index', { room: ROOM_ID, index: 0, ...getPushOptions() });
            });

            gotoLastLineBtn.addEventListener('click', () => {
                if (localState.lines && localState.lines.length > 0) {
                    isBlanked = false;
                    const lastIndex = localState.lines.length - 1;
                    socket.emit('update_index', { room: ROOM_ID, index: lastIndex, ...getPushOptions() });
                }
            });

            document.addEventListener('selectionchange', () => {
                if (document.activeElement === editor) {
                    handleCursorOrSelectionChange();
                }
            });

            function handleCursorOrSelectionChange() {
                clearTimeout(cursorSyncTimeout);
                cursorSyncTimeout = setTimeout(() => {
                    const broadcastMode = localState.push_settings?.broadcast_mode || 'manual';
                    if (broadcastMode !== 'follow_cursor') {
                        return;
                    }
                    socket.emit('cursor_sync', {
                        room: ROOM_ID,
                        cursor_pos: editor.selectionStart
                    });
                    pushCurrentLine();
                }, 100);
            }
            
            function initializeSpeechRecognition() {
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    showSpeechStatus('您的瀏覽器不支援語音識別功能。請使用最新版的 Chrome 瀏覽器。', 'error');
                    return false;
                }
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = speechLangSelect.value;
                recognition.maxAlternatives = 1;
                
                recognition.onstart = function() {
                    isRecording = true;
                    speechToggleBtn.disabled = false;
                    speechToggleBtn.classList.add('recording');
                    speechToggleBtn.textContent = '停止語音識別';
                    showSpeechStatus('語音識別已啟動，請開始說話...', 'success');
                };
                
                recognition.onresult = function(event) {
                    let newFinalTranscript = '';
                    let newInterimTranscript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            newFinalTranscript += transcript;
                        } else {
                            newInterimTranscript += transcript;
                        }
                    }
                    
                    if (newFinalTranscript) {
                        finalTranscript += newFinalTranscript;
                        lastSpeechTime = Date.now();
                        clearPendingInterimText();
                        processAndInsertFinalTranscript(newFinalTranscript);
                        setupSilenceDetection();
                    }
                    
                    interimTranscript = newInterimTranscript;
                    if (interimTranscript) {
                        handleInterimResult(interimTranscript);
                        showSpeechStatus(`識別中: ${interimTranscript}`, 'success');
                    }
                };
                
                recognition.onerror = function(event) {
                    console.error('語音識別錯誤:', event.error, event);
                    let shouldRestart = false;
                    let restartDelay = 1000;
                    let statusMsg = `語音識別錯誤: ${event.error}`;
                    let statusType = 'error';

                    switch (event.error) {
                        case 'no-speech':
                            statusMsg = '等待語音輸入...';
                            statusType = 'success';
                            shouldRestart = true;
                            restartDelay = 500;
                            break;
                        case 'audio-capture':
                            statusMsg = '麥克風錯誤，請檢查麥克風設定';
                            shouldRestart = true;
                            break;
                        case 'not-allowed':
                            statusMsg = '語音識別被拒絕，請允許麥克風權限後重新啟動';
                            stopSpeechRecognition();
                            break;
                        case 'network':
                            statusMsg = '網路連線問題，正在重試...';
                            statusType = 'success';
                            shouldRestart = true;
                            restartDelay = 2000;
                            break;
                        default:
                            statusMsg = `正在重新連線... (${event.error})`;
                            statusType = 'success';
                            shouldRestart = true;
                            break;
                    }

                    showSpeechStatus(statusMsg, statusType);

                    if (shouldRestart && isRecording) {
                        setTimeout(() => {
                            if (isRecording && recognition) {
                                try { recognition.start(); } catch (e) { stopSpeechRecognition(); }
                            }
                        }, restartDelay);
                    }
                };
                
                recognition.onend = function() {
                    if (isRecording) {
                        setTimeout(() => {
                            if (isRecording && recognition) {
                                try {
                                    recognition.start();
                                } catch (e) {
                                    if (e.name === 'InvalidStateError') {
                                        if (initializeSpeechRecognition()) {
                                            try { recognition.start(); } catch (e2) { stopSpeechRecognition(); }
                                        }
                                    } else {
                                        stopSpeechRecognition();
                                    }
                                }
                            }
                        }, 300);
                    } else {
                        stopSpeechRecognition();
                    }
                };
                return true;
            }
            
            function startSpeechRecognition() {
                if (isRecording) { stopSpeechRecognition(); }
                editor.focus();
                const textLength = editor.value.length;
                editor.selectionStart = editor.selectionEnd = textLength;
                if (!recognition) {
                    if (!initializeSpeechRecognition()) return;
                }
                recognition.lang = speechLangSelect.value;
                try {
                    recognition.start();
                    finalTranscript = '';
                    interimTranscript = '';
                } catch (e) {
                    showSpeechStatus(`啟動語音識別失敗: ${e.message}`, 'error');
                    if (initializeSpeechRecognition()) {
                        try { recognition.start(); } catch (e2) { showSpeechStatus(`語音識別啟動失敗: ${e2.message}`, 'error'); }
                    }
                }
            }
            
            function stopSpeechRecognition() {
                isRecording = false;
                if (recognition) {
                    try { recognition.stop(); } catch (e) {}
                }
                speechToggleBtn.disabled = false;
                speechToggleBtn.classList.remove('recording');
                speechToggleBtn.textContent = '開始語音識別';
                if (silenceTimer) clearTimeout(silenceTimer);
                if (editorUpdateTimer) clearTimeout(editorUpdateTimer);
                if (pushUpdateTimer) clearTimeout(pushUpdateTimer);
                commaCount = 0;
                if (interimTranscript) {
                    processAndInsertFinalTranscript(interimTranscript);
                    interimTranscript = '';
                }
                clearPendingInterimText();
                showSpeechStatus('語音識別已停止', 'success');
				// [新增] 3秒後自動隱藏狀態列
				setTimeout(() => {
					if (!isRecording) { // 再次確認使用者沒有馬上又按下開始
						speechStatus.style.display = 'none';
					}
				}, 3000);
            }
            
            function handleInterimResult(text) {
                if (!text.trim()) return;
                clearPendingInterimText();
                const cursorPos = editor.selectionStart;
                const textBefore = editor.value.substring(0, cursorPos);
                const textAfter = editor.value.substring(cursorPos);
                let separator = '';
                let willCreateNewLine = false;
                if (textBefore && !textBefore.endsWith('\n') && !textBefore.endsWith(' ')) {
                    separator = ' ';
                }
                const currentLineStart = textBefore.lastIndexOf('\n') + 1;
                const currentLineText = textBefore.substring(currentLineStart);
                if (currentLineText.length + text.length > maxLineLength) {
                    separator = '\n';
                    willCreateNewLine = true;
                }
                currentInterimText = separator + text;
                editor.value = textBefore + currentInterimText + textAfter;
                const newCursorPos = cursorPos + currentInterimText.length;
                editor.selectionStart = editor.selectionEnd = newCursorPos;
                scheduleCollaborationUpdate();
                setTimeout(scheduleLineNumberUpdate, interimUpdateDelay);
                if (isRecording) {
                    setTimeout(autoFollowCurrentLine, willCreateNewLine ? interimPushDelay : interimPushDelay);
                }
            }
            
            function clearPendingInterimText() {
                if (currentInterimText) {
                    const cursorPos = editor.selectionStart;
                    const textBefore = editor.value.substring(0, cursorPos - currentInterimText.length);
                    const textAfter = editor.value.substring(cursorPos);
                    editor.value = textBefore + textAfter;
                    editor.selectionStart = editor.selectionEnd = cursorPos - currentInterimText.length;
                    currentInterimText = '';
                    scheduleCollaborationUpdate();
                }
            }
            
            function processAndInsertFinalTranscript(text) {
                if (!text.trim()) return;
                const cursorPos = editor.selectionStart;
                const textBefore = editor.value.substring(0, cursorPos);
                const textAfter = editor.value.substring(cursorPos);
                let separator = '';
                let willCreateNewLine = false;
                if (textBefore && !textBefore.endsWith('\n') && !textBefore.endsWith(' ')) {
                    separator = ' ';
                }
                const currentLineStart = textBefore.lastIndexOf('\n') + 1;
                const currentLineText = textBefore.substring(currentLineStart);
                if (currentLineText.length + text.length > maxLineLength) {
                    separator = '\n';
                    willCreateNewLine = true;
                }
                const sentences = splitIntoSentences(text);
                const newText = sentences.join('\n');
                editor.value = textBefore + separator + newText + textAfter;
                const newCursorPos = cursorPos + separator.length + newText.length;
                editor.selectionStart = editor.selectionEnd = newCursorPos;
                scheduleCollaborationUpdate();
                setTimeout(scheduleLineNumberUpdate, finalUpdateDelay);
                if (isRecording) {
                    setTimeout(autoFollowCurrentLine, willCreateNewLine ? finalPushDelay : finalPushDelay);
                }
                setTimeout(() => {
                    if (editor.value !== localState.raw_text) {
                        socket.emit('update_script', { room: ROOM_ID, raw_text: editor.value });
                    }
                }, finalUpdateDelay);
            }
            
            function autoFollowCurrentLine() {
                const broadcastMode = localState.push_settings?.broadcast_mode || 'manual';
                if (broadcastMode !== 'automatic') return;
                const lineCount = editor.value.split('\n').length;
                const lastLineIndex = Math.max(0, lineCount - 1);
                if (lastLineIndex !== localState.current_index) {
                    socket.emit('update_index', {
                        room: ROOM_ID, 
                        index: lastLineIndex, 
                        raw_text: editor.value,
                        ...getPushOptions() 
                    });
                }
            }
            
            function setupSilenceDetection() {
                if (silenceTimer) clearTimeout(silenceTimer);
                silenceTimer = setTimeout(() => {
                    if (!isRecording) return;
                    const silenceDuration = Date.now() - lastSpeechTime;
                    if (silenceDuration >= longPauseThreshold) {
                        addSmartPunctuation('。', true);
                    } else if (silenceDuration >= mediumPauseThreshold) {
                        addSmartPunctuation('。');
                    } else if (silenceDuration >= shortPauseThreshold) {
                        addSmartPunctuation('，');
                    } else {
                        setupSilenceDetection();
                    }
                }, silenceCheckInterval);
            }
            
            function addSmartPunctuation(punctuation, forceNewline = false) {
                const cursorPos = editor.selectionStart;
                const textBefore = editor.value.substring(0, cursorPos);
                const textAfter = editor.value.substring(cursorPos);
                if (textBefore && !punctuationMarks.test(textBefore.slice(-1))) {
                    let insertText = punctuation;
                    let shouldAddNewline = forceNewline;
                    const currentLineStart = textBefore.lastIndexOf('\n') + 1;
                    const currentLineText = textBefore.substring(currentLineStart);
                    const currentLineLength = currentLineText.length;
                    const currentLineCommas = (currentLineText.match(/，/g) || []).length;
                    if (!shouldAddNewline) {
                        if (currentLineLength >= maxLineLength || (punctuation === '，' && currentLineCommas >= 1) || punctuation === '。') {
                            shouldAddNewline = true;
                        }
                    }
                    if (shouldAddNewline) {
                        insertText += '\n';
                        commaCount = 0;
                    } else if (punctuation === '，') {
                        commaCount++;
                    }
                    editor.value = textBefore + insertText + textAfter;
                    const newCursorPos = cursorPos + insertText.length;
                    editor.selectionStart = editor.selectionEnd = newCursorPos;
                    scheduleCollaborationUpdate();
                    if (shouldAddNewline && isRecording) {
                        setTimeout(autoFollowCurrentLine, finalPushDelay);
                    }
                }
            }

            function showSpeechStatus(message, type = 'success') {
                speechStatus.textContent = message;
                speechStatus.className = `speech-status ${type}`;
                speechStatus.style.display = 'block';
            }

            function splitIntoSentences(text) {
                if (text.length < 20) return [text];
                let sentences = [];
                let currentSentence = '';
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    currentSentence += char;
                    if (sentenceEndings.test(char) && currentSentence.length > 5) {
                        sentences.push(currentSentence.trim());
                        currentSentence = '';
                    }
                }
                if (currentSentence.trim()) {
                    sentences.push(currentSentence.trim());
                }
                return sentences.length > 0 ? sentences : [text];
            }

            speechToggleBtn.addEventListener('click', () => {
                if (isRecording) {
                    stopSpeechRecognition();
                } else {
                    startSpeechRecognition();
                }
            });
            speechLangSelect.addEventListener('change', () => {
                if (isRecording) {
                    stopSpeechRecognition();
                    setTimeout(startSpeechRecognition, 200);
                }
            });

            // Initial UI setup
            updateUI();
            scheduleLineNumberUpdate();

            // Easter Egg: Night Mode Toggle
            const authorSignature = document.querySelector('.author-signature');
            if (authorSignature) {
                authorSignature.style.cursor = 'pointer'; // Make it look clickable
                authorSignature.title = '切換日夜間模式'; // Add a tooltip

                const applyTheme = (theme) => {
                    if (theme === 'night') {
                        document.body.classList.add('night-mode');
                    } else {
                        document.body.classList.remove('night-mode');
                    }
                }

                authorSignature.addEventListener('click', () => {
                    const isNightMode = document.body.classList.contains('night-mode');
                    const newTheme = isNightMode ? 'day' : 'night';
                    localStorage.setItem('theme', newTheme);
                    applyTheme(newTheme);
                });

                // On page load, apply the saved theme
                const savedTheme = localStorage.getItem('theme');
                if (savedTheme) {
                    applyTheme(savedTheme);
                }
            }
        });
    </script>
</body>
</html>
