<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>即時字幕</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=KaiTi&display=swap" rel="stylesheet">
    <style>
        html, body { 
            margin: 0; 
            padding: 0; 
            width: 100%; 
            height: 100%; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Microsoft JhengHei", Roboto, sans-serif; 
            overflow: hidden;
            transition: background-color 0.3s; 
        }
        #subtitle-container {
            width: 100%;
            height: 100vh;
            box-sizing: border-box;
            font-weight: bold;
            line-height: 1.4;
            display: flex; /* Kept for horizontal centering */
            flex-direction: column;
            /* justify-content: center; /* REMOVED: Vertical alignment is now handled by JavaScript */
            overflow: hidden;
        }
        #subtitle-content {
            width: 100%; /* Make the content wrapper full-width */
            box-sizing: border-box;
            position: relative; /* ADDED: Ensures child offsetTop is relative to this element */
            /* MODIFIED: Added transform to transition */
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-out;
        }
        #subtitle-content.hidden {
            opacity: 0;
        }
        #subtitle-content p { margin: 0; }
        #status { position: absolute; top: 10px; left: 10px; font-size: 1.5vmin; color: #555; z-index: 10; }

        /* --- Scroll Mode Styles (Reverted to simple version) --- */
        #subtitle-container.scroll-mode {
            justify-content: flex-start;
            overflow-y: scroll;
            scroll-behavior: smooth;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        #subtitle-container.scroll-mode::-webkit-scrollbar { display: none; }
        
        #subtitle-container .line {
            margin: 0.1em 0;
            transition: opacity 0.5s ease;
            opacity: 0.4; /* Default faded state for all non-highlighted lines */
            width: 100%;
            box-sizing: border-box;
        }
        #subtitle-container .line.highlight {
            opacity: 1; /* Highlighted lines are fully opaque */
        }

        .scroll-padding { 
            height: 50vh; 
            flex-shrink: 0; 
        }

        /* --- Modal Styles --- */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .modal-overlay.visible { opacity: 1; visibility: visible; }
        .modal-content { background-color: #fff; padding: 30px; border-radius: 8px; text-align: center; transform: scale(0.9); transition: transform 0.3s; }
        .modal-overlay.visible .modal-content { transform: scale(1); }

        /* --- FAB Styles --- */
        .fab-container { position: fixed; bottom: 25px; right: 25px; z-index: 999; }
        .fab { width: 56px; height: 56px; background-color: #2196F3; color: white; border-radius: 50%; border: none; box-shadow: 0 2px 10px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; transition: transform 0.2s; }
        .fab:hover { background-color: #1976D2; }
        .fab.open { transform: rotate(45deg); }
        .fab-menu { position: absolute; bottom: 70px; right: 8px; display: flex; flex-direction: column; gap: 10px; opacity: 0; visibility: hidden; transition: opacity 0.2s, visibility 0.2s, transform 0.2s; transform: translateY(10px); }
        .fab-menu.open { opacity: 1; visibility: visible; transform: translateY(0); }
        .fab-menu-item { background-color: #fff; color: #333; border: none; border-radius: 8px; padding: 8px 16px; box-shadow: 0 1px 5px rgba(0,0,0,0.2); cursor: pointer; font-size: 14px; white-space: nowrap; }
        .fab-menu-item:hover { background-color: #f5f5f5; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- ADDED: QR Code Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator/qrcode.js"></script>
</head>
<body>
    <div id="status">正在連線...</div>
    <div id="subtitle-container">
        <div id="subtitle-content">等待字幕...</div>
    </div>

    <!-- ADDED: FAB and Menu -->
    <div class="fab-container">
        <div class="fab-menu" id="fab-menu">
            <button class="fab-menu-item" id="qrcode-btn">QRcode</button>
            <button class="fab-menu-item" id="copy-btn">複製字幕</button>
        </div>
        <button class="fab" id="fab">+</button>
    </div>

    <!-- ADDED: QR Code Modal -->
    <div id="qrcode-modal" class="modal-overlay">
        <div class="modal-content">
            <h4>觀眾端連結 QR Code</h4>
            <div id="qrcode-container" style="margin: 20px 0; min-width: 256px; min-height: 256px;"></div>
            <button id="qrcode-close-btn">關閉</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const socket = io();
            const ROOM_ID = "{{ room_id }}";
            const subtitleContainer = document.getElementById('subtitle-container');
            let subtitleContent = document.getElementById('subtitle-content');
            const statusElement = document.getElementById('status');
            const bodyElement = document.body;

            // --- ADDED: New element references ---
            const fab = document.getElementById('fab');
            const fabMenu = document.getElementById('fab-menu');
            const qrcodeBtn = document.getElementById('qrcode-btn');
            const copyBtn = document.getElementById('copy-btn');
            const qrcodeModal = document.getElementById('qrcode-modal');
            const qrcodeContainer = document.getElementById('qrcode-container');
            const qrcodeCloseBtn = document.getElementById('qrcode-close-btn');
            
            let heartbeatInterval;
            let lastPongTime = Date.now();
            let isScrollModeInitialized = false;
            let lastRawText = "";
            let lastContent = '';
            let lastStateForReposition = null; // Store state for repositioning on resize

            function startHeartbeat() {
                if (heartbeatInterval) clearInterval(heartbeatInterval);
                heartbeatInterval = setInterval(() => {
                    const now = Date.now();
                    socket.emit('ping', { room: ROOM_ID, timestamp: now });
                    if (now - lastPongTime > 10000) {
                        statusElement.textContent = "連線異常";
                        statusElement.style.color = '#FFA500';
                    }
                }, 60000);
            }

            socket.on('connect', () => { 
                statusElement.textContent = "已連線"; 
                statusElement.style.color = '#008000'; 
                socket.emit('join', { room: ROOM_ID }); 
                startHeartbeat();
            });
            socket.on('disconnect', () => { 
                statusElement.textContent = "連線中斷"; 
                statusElement.style.color = '#FF0000'; 
                if (heartbeatInterval) clearInterval(heartbeatInterval);
            });
            socket.on('pong', (data) => {
                lastPongTime = Date.now();
                const latency = lastPongTime - data.timestamp;
                statusElement.textContent = `已連線 (${latency}ms)`;
                statusElement.style.color = '#008000';
            });
            
            socket.on('state_update', (state) => {
                lastStateForReposition = state; // Cache the latest state
                const pushSettings = state.push_settings || { display_lines: 1, transition_mode: 'fade' };
                updateStyles(state.style_settings);

                const isScroll = pushSettings.transition_mode === 'scroll' || pushSettings.transition_mode === 'scroll-normal';

                // Reset container if mode changes from scroll to non-scroll
                if (!isScroll && isScrollModeInitialized) {
                    cleanupScrollContainer();
                    isScrollModeInitialized = false;
                }

                if (isScroll) {
                    subtitleContainer.style.justifyContent = 'flex-start'; // Reset for scroll mode
                    if (!isScrollModeInitialized || lastRawText !== state.raw_text) {
                        initializeScrollContainer(state.lines);
                        isScrollModeInitialized = true;
                        lastRawText = state.raw_text;
                    }
                    // MODIFIED: Pass style_settings to the function
                    updateScrollHighlight(state.current_index, pushSettings.display_lines, pushSettings.transition_mode, state.style_settings);
                } else {
                    // --- NEW LOGIC FOR MAIN-LINE CENTERING ---
                    const lines = state.lines || [];
                    const currentIndex = state.current_index || 0;
                    const displayLines = pushSettings.display_lines || 1;
                    const startIndex = Math.max(0, currentIndex - (displayLines - 1));
                    const linesToShow = lines.slice(startIndex, currentIndex + 1);

                    // Create a unique content key to check if DOM update is needed
                    const newContentKey = linesToShow.join('|') + currentIndex;

                    if (newContentKey === lastContent) return;
                    lastContent = newContentKey;

                    // Generate HTML with a specific ID for the main line
                    const newHtmlContent = linesToShow.map((line, i) => {
                        const lineIndex = startIndex + i;
                        const isMainLine = (lineIndex === currentIndex);
                        const id = isMainLine ? 'main-line' : '';
                        const parsedLine = marked.parse(cleanLineForDisplay(line), { gfm: true, breaks: true }).replace(/^<p>|<\/p>$/g, '');
                        return `<p id="${id}">${parsedLine}</p>`;
                    }).join('');

                    if (pushSettings.transition_mode === 'fade') {
                        subtitleContent.classList.add('hidden');
                        setTimeout(() => {
                            updateDirectContent(newHtmlContent, state.style_settings, state.current_index);
                            subtitleContent.classList.remove('hidden');
                        }, 150);
                    } else { // 'direct' mode
                        updateDirectContent(newHtmlContent, state.style_settings, state.current_index);
                    }
                }
            });
            
            function cleanLineForDisplay(line) {
                return line.replace(/^§\s*/, '').replace(/^#\s*/, '');
            }

            function updateStyles(styles) {
                if (!styles) return;
                const REFERENCE_WIDTH = 1920;

                bodyElement.style.backgroundColor = styles.bg_color;
                
                const userMargin = styles.margin !== undefined ? styles.margin : 30;
                const userFontSize = styles.font_size !== undefined ? styles.font_size : 100;
                const textAlign = styles.text_align || 'left';
                const viewerWidth = subtitleContainer.clientWidth;

                // The verticalAlign logic is now handled inside updateDirectContent

                if (viewerWidth > 0) {
                    const actualMargin = (userMargin / REFERENCE_WIDTH) * viewerWidth;
                    const textAreaWidth = viewerWidth - (actualMargin * 2);
                    
                    const referenceTextAreaWidth = REFERENCE_WIDTH - (userMargin * 2);
                    const actualFontSize = (userFontSize / referenceTextAreaWidth) * textAreaWidth;

                    const containerStyles = {
                        color: styles.fg_color,
                        fontFamily: styles.font_family,
                        textAlign: textAlign,
                        paddingLeft: `${actualMargin}px`,
                        paddingRight: `${actualMargin}px`,
                        fontSize: `${actualFontSize}px`
                    };
                    Object.assign(subtitleContainer.style, containerStyles);
                    subtitleContent.style.textAlign = textAlign;
                }
            }

            function initializeScrollContainer(lines) {
                subtitleContainer.innerHTML = ''; // Clear container
                subtitleContainer.classList.add('scroll-mode');

                const topPadding = document.createElement('div');
                topPadding.className = 'scroll-padding';
                subtitleContainer.appendChild(topPadding);

                lines.forEach((line, index) => {
                    const p = document.createElement('p');
                    p.id = `line-${index}`;
                    p.className = 'line';
                    p.innerHTML = cleanLineForDisplay(line).replace(/\n/g, '<br>');
                    subtitleContainer.appendChild(p);
                });

                const bottomPadding = document.createElement('div');
                bottomPadding.className = 'scroll-padding';
                subtitleContainer.appendChild(bottomPadding);
            }
            
            function cleanupScrollContainer() {
                subtitleContainer.classList.remove('scroll-mode');
                subtitleContainer.innerHTML = '<div id="subtitle-content">等待字幕...</div>';
                subtitleContent = document.getElementById('subtitle-content');
                subtitleContent.style.transform = 'translateY(0px)'; // Reset transform
            }

            function updateScrollHighlight(currentIndex, displayLines, transitionMode, style_settings) {
                const startIndex = Math.max(0, currentIndex - (displayLines - 1));
                
                document.querySelectorAll('#subtitle-container .line').forEach(el => {
                    const lineIndex = parseInt(el.id.split('-')[1]);

                    if (lineIndex > currentIndex) {
                        el.style.opacity = '0';
                    } else if (lineIndex >= startIndex && lineIndex <= currentIndex) {
                        el.style.opacity = '1'; // Highlighted line
                    } else {
                        el.style.opacity = (transitionMode === 'scroll-normal') ? '1' : '0.4';
                    }
                });

                const targetEl = document.getElementById(`line-${startIndex}`);
                if (targetEl) {
                    const verticalAlign = style_settings?.vertical_align || 'center';
                    let blockPosition = 'center';
                    if (verticalAlign === 'top') {
                        blockPosition = 'start';
                    } else if (verticalAlign === 'bottom') {
                        blockPosition = 'end';
                    }
                    targetEl.scrollIntoView({ behavior: 'smooth', block: blockPosition, inline: 'nearest' });
                }
            }

            function updateDirectContent(newHtml, styles, currentIndex) {
                subtitleContent.innerHTML = newHtml;

                requestAnimationFrame(() => {
                    const mainLineElement = document.getElementById('main-line');
                    const verticalAlign = styles?.vertical_align || 'center';

                    if (mainLineElement) {
                        const containerHeight = subtitleContainer.clientHeight;
                        const contentHeight = subtitleContent.offsetHeight;
                        const mainLineTop = mainLineElement.offsetTop;
                        const mainLineHeight = mainLineElement.offsetHeight;
                        
                        let targetY;
                        if (verticalAlign === 'top') {
                            // 靠上：主行頂部對齊容器頂部
                            targetY = mainLineTop;
                        } else if (verticalAlign === 'bottom') {
                            // ★ 修正靠下計算：主行底部對齊容器底部
                            targetY = mainLineTop + mainLineHeight - containerHeight;
                        } else { // 'center'
                            // ★ 修正置中計算：主行中心對齊容器中心
                            const mainLineCenter = mainLineTop + (mainLineHeight / 2);
                            const containerCenter = containerHeight / 2;
                            targetY = mainLineCenter - containerCenter;
                        }
                        
                        const offset = -targetY;
                        subtitleContent.style.transform = `translateY(${offset}px)`;

                    } else if (subtitleContent.firstChild) {
                        // 處理沒有主行的情況（如強制字幕）
                        const containerHeight = subtitleContainer.clientHeight;
                        const contentHeight = subtitleContent.offsetHeight;
                        
                        let offset = 0;
                        if (verticalAlign === 'top') {
                            offset = -subtitleContent.offsetTop;
                        } else if (verticalAlign === 'bottom') {
                            // ★ 修正：確保內容底部對齊容器底部
                            offset = containerHeight - contentHeight - subtitleContent.offsetTop;
                        } else { // 'center'
                            // ★ 修正：確保內容中心對齊容器中心
                            offset = (containerHeight - contentHeight) / 2 - subtitleContent.offsetTop;
                        }
                        subtitleContent.style.transform = `translateY(${offset}px)`;
                    } else {
                        subtitleContent.style.transform = 'translateY(0px)';
                    }
                });
            }

            socket.on('force_subtitle', (data) => {
                if (isScrollModeInitialized) {
                    cleanupScrollContainer();
                    isScrollModeInitialized = false;
                }
                const text = data.text || '';
                lastContent = text; // Update lastContent to prevent unwanted transitions
                
                const newHtml = marked.parse(text, { gfm: true, breaks: true });
                // For forced content, we don't have a "main line", so we use the fallback in updateDirectContent
                updateDirectContent(newHtml, lastStateForReposition?.style_settings || {}, -1);
            });

            // Recalculate position on window resize
            window.addEventListener('resize', () => {
                if (lastStateForReposition && !isScrollModeInitialized) {
                    // Re-trigger the positioning logic with the last known state
                    updateDirectContent(subtitleContent.innerHTML, lastStateForReposition.style_settings, lastStateForReposition.current_index);
                }
            });

            // --- ADDED: FAB, Modal, and Copy Logic ---
            fab.addEventListener('click', () => {
                fab.classList.toggle('open');
                fabMenu.classList.toggle('open');
            });

            copyBtn.addEventListener('click', () => {
                fab.classList.remove('open');
                fabMenu.classList.remove('open');

                if (!lastStateForReposition || !lastStateForReposition.lines) {
                    alert('沒有可複製的文本內容。');
                    return;
                }

                // Reconstruct the full, clean script text from the stored state
                const textToCopy = lastStateForReposition.lines
                    .map(line => line.replace(/^§\s*/, '')) // Also remove bookmark characters
                    .join('\n');
                
                if (navigator.clipboard && textToCopy) {
                    navigator.clipboard.writeText(textToCopy).then(() => {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = '已複製!';
                        setTimeout(() => { copyBtn.textContent = originalText; }, 2000);
                    }, (err) => {
                        alert('複製失敗: ' + err);
                        console.error('Copy failed: ', err);
                    });
                } else {
                    alert('複製功能不受支援或沒有內容可複製。');
                }
            });

            qrcodeBtn.addEventListener('click', () => {
                const url = window.location.href;
                qrcodeContainer.innerHTML = '';
                try {
                    const qr = qrcode(0, 'L');
                    qr.addData(url);
                    qr.make();
                    const dataUrl = qr.createDataURL(6, 10);
                    const imgElement = document.createElement('img');
                    imgElement.src = dataUrl;
                    imgElement.alt = 'Viewer Link QR Code';
                    imgElement.style.width = '256px';
                    imgElement.style.height = '256px';
                    qrcodeContainer.appendChild(imgElement);
                    qrcodeModal.classList.add('visible');
                } catch (e) {
                    console.error('QR Code generation failed:', e);
                    alert('產生 QR Code 失敗！');
                }
                fab.classList.remove('open');
                fabMenu.classList.remove('open');
            });

            function closeModal() {
                qrcodeModal.classList.remove('visible');
            }

            qrcodeCloseBtn.addEventListener('click', closeModal);
            qrcodeModal.addEventListener('click', (e) => {
                if (e.target === qrcodeModal) closeModal();
            });

        });
    </script>
</body>
</html>;
            });

            function closeModal() {
                qrcodeModal.classList.remove('visible');
            }

            qrcodeCloseBtn.addEventListener('click', closeModal);
            qrcodeModal.addEventListener('click', (e) => {
                if (e.target === qrcodeModal) closeModal();
            });

        });
    </script>
</body>
</html>
